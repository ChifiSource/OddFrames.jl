var documenterSearchIndex = {"docs":
[{"location":"OddFrame/#AbstractOddFrame","page":"OddFrames","title":"AbstractOddFrame","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"OddFrames are a name given to any type that is a sub-type of AbstractOddFrame. AbstractOddFrames must all hold the following fields:","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"labels::Array/Tuple{Symbol}\ncolumns::Array/Tuple{Any}\ntypes::Array/Tuple{Type}\nhead::Function\ndtype::Function\nnot::Function\nonly::Function\ndescribe::Function","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"AbstractOddFrame","category":"page"},{"location":"OddFrame/#AbstractMutableOddFrame","page":"OddFrames","title":"AbstractMutableOddFrame","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"AbstractMutableOddFrame is similar to AbstractOddFrame, only requires that both the OddFrame and its values are mutable. Along with this comes these additional features, some of which are shared with AbstractOddFrame","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"labels::Array{Symbol}\ncolumns::Array{Any}\ntypes::Array\nhead::Function\ndtype::Function\nnot::Function\nonly::Function\ndescribe::Function\ndrop!::Function\ndtype!::Function\nmerge!::Function\nonly!::Function\napply!::Function\nfill!::Function","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"OddFrames.AbstractMutableOddFrame","category":"page"},{"location":"OddFrame/#OddFrame","page":"OddFrames","title":"OddFrame","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"OddFrame","category":"page"},{"location":"OddFrame/#ImmutableOddFrame","page":"OddFrames","title":"ImmutableOddFrame","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"ImmutableOddFrame","category":"page"},{"location":"OddFrame/#Indexing","page":"OddFrames","title":"Indexing","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"Indexing in Oddframes.jl has a few key consistencies that are universal in the package and important to note. The first of these is the different types you can index with. The operation of the indexing is going to change depending on what type we are providing. The first way to index an OddFrame is by using a symbol. This will index the labels, and return the corresponding column of data.","category":"page"},{"location":"OddFrame/#Indexing-columns","page":"OddFrames","title":"Indexing columns","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"getindex(::AbstractOddFrame, ::Symbol)","category":"page"},{"location":"OddFrame/#Base.getindex-Tuple{AbstractOddFrame, Symbol}","page":"OddFrames","title":"Base.getindex","text":"Interface\nIndexing\n\ngetindex(od::AbstractOddFrame, col::Symbol) -> ::Array{Any}\n\nGets the corresponding index of columns from col's position in labels. Returns a 1-D array of the column's data.\n\nexample\n\nod = OddFrame(:A => [5, 10, 15])\nod[:A]\n[5, 10, 15]\n\n\n\n\n\n","category":"method"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"The same functionality can also be achieved with a string.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"getindex(::AbstractOddFrame, ::Symbol)","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"We can also use the at key-word argument, which always denotes that we would like to call a column. Otherwise, indexing with an integer will always call the observation. We can also index in this same way with a range.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"getindex(::AbstractOddFrame; at::UnitRange)","category":"page"},{"location":"OddFrame/#Base.getindex-Tuple{AbstractOddFrame}","page":"OddFrames","title":"Base.getindex","text":"Interface\nIndexing\n\ngetindex(od::AbstractOddFrame, axis::UnitRange) -> ::Vector{Array{any}}\n\nIndexing Returns all columns within range at.\n\nexample\n\nod = OddFrame(:A => [5, 10, 15], :B => [5, 10, 15])\nod[1:2]\n[[5, 10, 15], [5, 10, 15]]\n\n\n\n\n\n","category":"method"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"getindex(::AbstractOddFrame; at::Int64)","category":"page"},{"location":"OddFrame/#Indexing-rows","page":"OddFrames","title":"Indexing rows","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"Indexing full rows can be done by simply applying the same indexing but replacing the key-word argument at with a positional argument.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"getindex(::AbstractOddFrame, ::Int64)","category":"page"},{"location":"OddFrame/#Base.getindex-Tuple{AbstractOddFrame, Int64}","page":"OddFrames","title":"Base.getindex","text":"Interface\nIndexing\n\ngetindex(od::AbstractOddFrame, observation::Int64, at = 1) -> ::Any\n\nUsed to select an observation observation from column at on od.\n\nexample\n\nod = OddFrame(:A => [5, 10, 15], :B => [8, 12, 10])\nod[1, at = 1]\n\n5\n\n\n\n\n\n","category":"method"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"getindex(::AbstractOddFrame, ::UnitRange)","category":"page"},{"location":"OddFrame/#Indexing-observations","page":"OddFrames","title":"Indexing observations","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"Row indexes are done with three different types, the BitArray, Integers, and UnitRanges. The latter two can be done using the same indexing calls. We use the at key-word here to denote which column we would like to call.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"getindex(::AbstractOddFrame, ::Int64; at::Any)","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"getindex(::AbstractOddFrame, ::BitArray)","category":"page"},{"location":"OddFrame/#Base.getindex-Tuple{AbstractOddFrame, BitArray}","page":"OddFrames","title":"Base.getindex","text":"Interface\nIndexing\n\ngetindex(od::AbstractOddFrame, mask::BitArray) -> ::OddFrame\n\nDrops values when mask's equivalent index is false. Can be used to filter data. found on the OddFrame. Does not mutate the data, provides a return.\n\nexample\n\nod = OddFrame(:A => [5, 10, 15])\nod[od[:A] .== 5]\ncolumns(od)\n\n[5]\n\n\n\n\n\n","category":"method"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"getindex(::AbstractOddFrame, ::UnitRange)","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"These same indexing ideas carry into the member functions and the rest of the module, so it is certainly something to pay attention to.","category":"page"},{"location":"OddFrame/#Iteration","page":"OddFrames","title":"Iteration","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"Iteration using OddFrames.jl is also incredibly simple. There are a few ways we can iterate an OddFrame. By default, iterating over the OddFrame will loop the columns of the OddFrame.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"iterate(::AbstractOddFrame)","category":"page"},{"location":"OddFrame/#Base.iterate-Tuple{AbstractOddFrame}","page":"OddFrames","title":"Base.iterate","text":"Interface\nIteration\n\niterate(fg::OddFrameContainer, axis::Int64) -> ::Any\n\nPartitions OddFrame columns to be iterated.\n\nexample\n\nod = OddFrame(:A => [5, 10, 15])\nod2 = OddFrame(:B => [5, 10, 11])\nfg = FrameGroup(od, od2)\n\nfg[1]\n\n[5, 10, 15]\n\n\n\n\n\n","category":"method"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"However, in order to iterate names, or explicitly call the columns to be iterated, you can use labels() and columns() respectively.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"columns(::AbstractOddFrame)","category":"page"},{"location":"OddFrame/#OddFrames.columns-Tuple{AbstractOddFrame}","page":"OddFrames","title":"OddFrames.columns","text":"Interface\nIteration\n\ncolumns(od::AbstractOddFrame) -> ::Array{AbstractArray}\n\nReturns an iterable Array of the columns in an OddFrame.\n\nexample\n\nod = OddFrame(:A => [1, 2, 3], :B => [5, 8, 3])\ncolumns(od)\n\n[[1, 2, 3], [5, 8, 3]]\n\n\n\n\n\n","category":"method"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"labels(::AbstractOddFrame)","category":"page"},{"location":"OddFrame/#OddFrames.labels-Tuple{AbstractOddFrame}","page":"OddFrames","title":"OddFrames.labels","text":"Interface\nIteration\n\nlabels(fg::OddFrameContainer) -> ::Vector{Symbol}\n\nThis quickly returns an iterable Array of the frames' labels in a framegroup.\n\nexample\n\nlabels = [:od1, :od2]\nfg = FrameGroup(OddFrame(:y => [5, 8, 2]), OddFrame(:x => [5, 15]),\nlabels = labels)\nlabels(fg)\n\n[:od1, :od2]\n\n\n\n\n\n","category":"method"},{"location":"OddFrame/#Member-Functions","page":"OddFrames","title":"Member Functions","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"OddFrames have member functions. These functions are provided as fields of the OddFrame. That being said, you can access them how you normally would with fields. The advantage to this is that we can mutate the OddFrame internally. For example, here is a call of head:","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"od = OddFrame(:A => [5, 10, 15, 20])\nod.head(5)","category":"page"},{"location":"OddFrame/#Non-mutating-Member-Functions","page":"OddFrames","title":"Non-mutating Member Functions","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"These functions can return a mutated frame, but will not mutate the data inside of the OddFrame.","category":"page"},{"location":"OddFrame/#Introspective","page":"OddFrames","title":"Introspective","text":"","category":"section"},{"location":"OddFrame/#head","page":"OddFrames","title":"head","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"The od.head() member function will show x number of rows of the OddFrame.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"head(x::Int64; html = :show) = _head(labels, columns, types, x,\nhtml = html)\nhead() = _head(labels, columns, types, 5)","category":"page"},{"location":"OddFrame/#dtype","page":"OddFrames","title":"dtype","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"od.dtype() reveals the data-type of a given column by symbol index.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"dtype(x::Symbol) = typeof(types[findall(x->x == x,\n                        labels)[1]][1])","category":"page"},{"location":"OddFrame/#describe","page":"OddFrames","title":"describe","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"od.describe() describes each column, or a particular column's features.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"describe() = _describe(labels, columns, types)\ndescribe(col::Symbol) = _describe(symb, labels, columns, types)","category":"page"},{"location":"OddFrame/#Filtering","page":"OddFrames","title":"Filtering","text":"","category":"section"},{"location":"OddFrame/#not","page":"OddFrames","title":"not","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"Not excludes a symbol, range, or integer position from a column.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"not(ls::Symbol ...) = _not(ls, labels, columns)\nnot(ls::UnitRange ...) = _not(ls, labels, columns)\nnot(ls::Int64 ...) = _not(ls, labels, columns)","category":"page"},{"location":"OddFrame/#only","page":"OddFrames","title":"only","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"Only excludes all of the values except for the one provided.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"only(ls::Symbol ...) = _only(ls, labels, columns)\nonly(ls::UnitRange ...) = _only(ls, labels, columns)\nonly(ls::Int64 ...) = _only(ls, labels, columns)","category":"page"},{"location":"OddFrame/#Operations","page":"OddFrames","title":"Operations","text":"","category":"section"},{"location":"OddFrame/#apply","page":"OddFrames","title":"apply","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"Apply will apply f to the columns.","category":"page"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"apply(f::Function) = apply(f, labels, columns)","category":"page"},{"location":"OddFrame/#Mutating-Member-Functions","page":"OddFrames","title":"Mutating Member Functions","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"These functions will mutate your type! Be careful!","category":"page"},{"location":"OddFrame/#drop!","page":"OddFrames","title":"drop!","text":"","category":"section"},{"location":"OddFrame/","page":"OddFrames","title":"OddFrames","text":"The drop! function can drop a column, row, or values that meet certain parameters","category":"page"},{"location":"CHANGELOG/#CHANGES","page":"Changelog","title":"CHANGES","text":"","category":"section"},{"location":"CHANGELOG/#Labels-Bug-fix-TODO-TODO-C-(TODO-Carryover)","page":"Changelog","title":"Labels - Bug fix - TODO - TODO C (TODO Carryover)","text":"","category":"section"},{"location":"CHANGELOG/#","page":"Changelog","title":"","text":"","category":"section"},{"location":"CHANGELOG/#.0.8-Rework-adjustment","page":"Changelog","title":"0.0.8 Rework adjustment","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"All kinds of things reworked on the back-end\nDocumentation overhaul\ndrop!() etc. calls with functions.","category":"page"},{"location":"CHANGELOG/#.0.7-Enhancing-assets,-extending-methods.","page":"Changelog","title":"0.0.7 Enhancing assets, extending methods.","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"TODO C Add more information and type casting for dates, times, and other feature-types.\nTODO C Add image_URI, Dates, and more to feature types.\nTODO C Add majority for classes","category":"page"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"TODO Write test portion. TODO Finish all documentation. TODO fill()/fill!() with some fill functions. TODO Add more casts","category":"page"},{"location":"CHANGELOG/#.0.6-Enriched-API","page":"Changelog","title":"0.0.6 Enriched API","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"TODO C Add more information for dates and times, and other feature-types.\nTODO C Add majority class for classes.\nTODO C Add image URI to feature-types.\nAdded ! for mutating methods\nEnhanced the methods file significantly.\nAdded complex documentation.\nAdded linearalgebra.\nAdded extras and basetools\nAdded Grouping with FrameGroup\nAdded casts.jl, and more casts coming.\nmerge!, merge, not, only!, only pivot!, and fill!/fill.\nAdded documentation, testing projects\nCreated template for future docs here.","category":"page"},{"location":"CHANGELOG/#.0.5-FIXES-AND-ADDITIONS","page":"Changelog","title":"0.0.5 FIXES AND ADDITIONS","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"TODO C Add more information for dates and times, and other feature-types.\nTODO Add string parser to parse data-types that are strings.\nTODO C Add majority class for classes.\nTODO C Add image URI to feature-types.\nTODO C Add ! for mutating methods\nAdded immutableoddframe with tuples and an immutable type.\nAdded length(), size(), and width() bindings\nAdded _dtype function\nAdded Dict dispatch to OddFrame\nMoved indexing and iter into indexiter.jl\nTODO Separate data-types and labeled attributes\nBug fix Fixed problem with boolean indexing!\nBug fix Fixed the issue with bad feature-type labeling.\nExtended the abilities of the feature-type determiner.\nTODO Add more information for dates and times.\nTODO Add majority class for classes.\nTODO Add image URI to feature-types.\nTODO Add ! for mutating methods\nTODO Add immutableoddframe with tuples and an immutable type.\nNew Feature added dropna()\nAdded iterators for calling columns or labels, etc.\nUpdated logo","category":"page"},{"location":"CHANGELOG/#.0.4-REWORK","page":"Changelog","title":"0.0.4 REWORK","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"Reworked the handling of indexes.\nAdded shape() method\nAdded read_csv() method\nAdded new table styling with information tool-tips.\nTODO Need to fix boolean indexing!\nTODO Need to create methods.jl\nTODO Need to make column/row iterators\nTODO Need to add highest set-count\nTODO Need to fix figuring out type function (a little more accurate.)\n\nAdded Name and length check throws\nAdded column descriptors","category":"page"},{"location":"CHANGELOG/#.0.3-**init**","page":"Changelog","title":"0.0.3 init","text":"","category":"section"},{"location":"CHANGELOG/","page":"Changelog","title":"Changelog","text":"initalized this repository with all of the files in it.","category":"page"},{"location":"FrameGroups/#FrameGroups-;)","page":"FrameGroups","title":"FrameGroups ;)","text":"","category":"section"},{"location":"CONTRIBUTING/#Contribute-your-code-to-OddFrames.jl","page":"Contributing","title":"Contribute your code to OddFrames.jl","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Have an awesome idea you want to try out? Want to integrate some new ideas and techniques into OddFrames.jl to make it better? Feel free to fork and try contributing such. There are a few things you should know about contributing First of all, whenever you want to make a change, the CHANGELOG.MD here is pretty easy to comprehend, and somewhat loose fitting. Just describe what you have done in terms of a full implementation or improving of something.","category":"page"},{"location":"CONTRIBUTING/#Some-notes.","page":"Contributing","title":"Some notes.","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"First of all, always when you fork, create your development branch from the Unstable branch. If you do not do this, it will make a lot more work for maintainers to review your pull request, as you could have been writing in a function that was dramatically altered between master and Unstable. This package has one release between breaking versions, starting with 0.1.0. In other words, pushes to master are going to always be arranged by 0.1.0, 0.1.5, 0.2.0, 0.2.5... and so forth, incrementing by .5. So please fork Unstable instead of main.","category":"page"},{"location":"CONTRIBUTING/#Follow-the-basic-methodology.","page":"Contributing","title":"Follow the basic methodology.","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"It should not be hard to contribute code that looks like it belongs in this package, and there are many approaches one could have. Even if the implementation is new syntax, given all the different syntax expressions in this library, it could still belong in this library. However, doing things that do not align with what is going on at the core here at all could be problematic.","category":"page"},{"location":"CONTRIBUTING/#Thanks","page":"Contributing","title":"Thanks","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing","title":"Contributing","text":"Thanks for considering my concerns with your commits, and how to get your code pushed to master. Thanks for your contributions. ","category":"page"},{"location":"Methods/#Hi","page":"Methods","title":"Hi","text":"","category":"section"},{"location":"Internals/#","page":"Internal API","title":"","text":"","category":"section"},{"location":"Functions/#null","page":"Functions","title":"null","text":"","category":"section"},{"location":"README/#Welcome-to-OddFrames.jl","page":"Overview","title":"Welcome to OddFrames.jl","text":"","category":"section"},{"location":"README/","page":"Overview","title":"Overview","text":"OddFrames is a new type of data-management framework that holds a core methodology in a paradigm-less world. The framework contains all you need to manipulate, extract, clean, and work with data. The great thing about this library is that due to the fact this is Julia, the types integrate really well with the base. As a result, there really is often not much need for data-types that are not as flexible as the base types. OddFrames follows the following methodology:","category":"page"},{"location":"README/","page":"Overview","title":"Overview","text":"Paradigm should be based on functionality.\nEverything should be extendable.\nImmutability and Mutability should be managed.\nData stored for values should be kept minimal.\nBoolean, and multiple types of indexing and methods should be used to control data.\nData should be manipulated both as a multi-dimensional array AND a vector of 1-dimensional features.\nData should align with default mathematical functions.\nFunction calls should be consistent and versatile, no matter the type.\nThe user should always be in control of the types defined in their current environment.","category":"page"},{"location":"ExtendingOddFrames/#Developer-API","page":"Extending OddFrames","title":"Developer API","text":"","category":"section"}]
}
